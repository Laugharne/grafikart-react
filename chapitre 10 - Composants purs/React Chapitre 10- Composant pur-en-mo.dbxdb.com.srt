1
00:00:00,000 --> 00:00:00,000
 Youtube subtitles download by mo.dbxdb.com 

2
00:00:00,000 --> 00:00:02,589
a perdu dans ce nouveau chapitre qui est

3
00:00:01,589 --> 00:00:05,970
selon moi un des chapitres les plus

4
00:00:02,970 --> 00:00:07,009
importants de cette formation donc soyez

5
00:00:05,009 --> 00:00:08,020
vraiment vigilants et ne survenait pas

6
00:00:07,020 --> 00:00:09,009
ce chapitre là parce qu'il vous

7
00:00:08,009 --> 00:00:10,240
permettra de comprendre beaucoup de

8
00:00:09,240 --> 00:00:11,889
choses sur le fonctionnement de

9
00:00:10,889 --> 00:00:13,370
rillettes

10
00:00:11,370 --> 00:00:15,110
dans ce chapitre on va parler de

11
00:00:13,110 --> 00:00:17,839
l'immutabilité des composants pure et de

12
00:00:15,839 --> 00:00:20,699
comment react fonctionne au niveau des

13
00:00:17,699 --> 00:00:22,460
renders petit rappel même si on l'a déjà

14
00:00:20,460 --> 00:00:24,109
évoqué à chaque fois que l'on fait un

15
00:00:22,109 --> 00:00:26,090
set states que ferrer acte que c'est

16
00:00:24,090 --> 00:00:28,519
qu'il ne déclenche un rendu donc il va

17
00:00:26,519 --> 00:00:30,529
ré appelé les fonctions dans le cadre de

18
00:00:28,529 --> 00:00:33,689
composants souffrent de fonction ou dans

19
00:00:30,689 --> 00:00:34,090
le cadre de fond de composants sous

20
00:00:33,090 --> 00:00:36,469
forme de classe il va ré appelé la

21
00:00:34,469 --> 00:00:38,600
fonction renders cette fonction renders

22
00:00:36,600 --> 00:00:41,940
va créer un arbre avec la fonction qu

23
00:00:38,940 --> 00:00:42,399
est telement de réac et ensuite reato

24
00:00:41,399 --> 00:00:44,780
d'hommes pourra comparer à la version

25
00:00:42,780 --> 00:00:46,520
précédente pour savoir quels changements

26
00:00:44,520 --> 00:00:48,620
il doit effectuer donc de manière

27
00:00:46,620 --> 00:00:50,600
générale ces opérations se font très

28
00:00:48,600 --> 00:00:53,579
rapidement et ça fonctionne de manière

29
00:00:50,579 --> 00:00:54,399
plutôt transparente pour l'utilisateur

30
00:00:53,399 --> 00:00:56,809
le problème c'est que parfois dans la

31
00:00:54,809 --> 00:00:58,160
partie et renders vous allez avoir un

32
00:00:56,160 --> 00:00:59,170
brain logic qui peut coûter un petit peu

33
00:00:58,170 --> 00:01:02,730
en termes de performance et ça peut

34
00:00:59,730 --> 00:01:03,640
donner un retour très mauvais au niveau

35
00:01:02,640 --> 00:01:05,270
de l'utilisateur

36
00:01:03,270 --> 00:01:06,099
alors pour illustrer le problème on va

37
00:01:05,099 --> 00:01:08,510
reprendre le même exercice qu'on en ait

38
00:01:06,510 --> 00:01:10,188
fait précédemment donc le listing de

39
00:01:08,188 --> 00:01:13,619
produits et on va introduire un petit 1

40
00:01:10,619 --> 00:01:15,680
un petit délai au niveau du rendu donc

41
00:01:13,680 --> 00:01:17,030
j'ai créé au niveau de mon index point

42
00:01:15,030 --> 00:01:18,369
html cette petite fonction qui permet de

43
00:01:17,369 --> 00:01:20,959
bloquer et d'attendre pendant un petit

44
00:01:18,959 --> 00:01:22,670
moment je n'ai pas utilisé de timer

45
00:01:20,670 --> 00:01:25,170
volontairement l'idée c'est de bloquer

46
00:01:22,170 --> 00:01:27,530
le script pendant une petite durée donc

47
00:01:25,530 --> 00:01:29,360
au niveau de mon à point g est dans la

48
00:01:27,360 --> 00:01:33,970
partie producteurs aux comptes s'imagine

49
00:01:29,970 --> 00:01:34,090
c'est que peut-être pour récupérer un

50
00:01:33,090 --> 00:01:36,619
extrait du contenu de la fiche produit

51
00:01:34,619 --> 00:01:36,150
ou je ne sais quoi d'autre ça met un

52
00:01:36,150 --> 00:01:38,750
petit moment

53
00:01:36,750 --> 00:01:40,520
par exemple on convertit de marque dans

54
00:01:38,520 --> 00:01:43,860
html et le parent seraient pas très

55
00:01:40,860 --> 00:01:44,259
efficace ou pour simuler les choses ici

56
00:01:43,259 --> 00:01:45,729
on va mettre un wait de 500

57
00:01:44,729 --> 00:01:48,680
millisecondes

58
00:01:45,680 --> 00:01:49,209
donc si je sauvegarde on voit que la

59
00:01:48,209 --> 00:01:51,709
première fois ça même qui tend à être

60
00:01:49,709 --> 00:01:53,110
rendue mais c'est tout à fait normal

61
00:01:51,110 --> 00:01:56,849
parce que ben ali a ainsi produit et du

62
00:01:53,849 --> 00:01:57,130
coup c'est 6 5 fois 5 ça fait 3 secondes

63
00:01:56,130 --> 00:02:00,810
maintenant dès que je tape des choses

64
00:01:57,810 --> 00:02:01,060
vous allez voir que même si je suis pas

65
00:02:00,060 --> 00:02:03,140
en train de taper sur mon clavier

66
00:02:01,140 --> 00:02:05,000
les choses continuent à apparaître avec

67
00:02:03,000 --> 00:02:07,650
du délai donc il ya globalement une

68
00:02:05,650 --> 00:02:09,150
une à trois secondes entre chaque

69
00:02:07,150 --> 00:02:10,039
affichage de lettres et ça donne un

70
00:02:09,039 --> 00:02:13,660
ressenti qui est pas forcément terrible

71
00:02:10,660 --> 00:02:15,330
à l'utilisateur alors pourquoi un à ce

72
00:02:13,330 --> 00:02:17,190
délai la tout simplement parce que à

73
00:02:15,190 --> 00:02:20,460
chaque fois que l'on tape quelque chose

74
00:02:17,460 --> 00:02:23,289
search bar va rappeler la méthode and

75
00:02:20,289 --> 00:02:25,020
feel it up exchange sur le parent est le

76
00:02:23,020 --> 00:02:27,240
parent va faire un vis cette state ont

77
00:02:25,240 --> 00:02:29,250
vu que j'ai un set state ici la fonction

78
00:02:27,250 --> 00:02:31,710
renders va être ré appelé et pour under

79
00:02:29,710 --> 00:02:33,780
mais il a besoin de rendre search bar se

80
00:02:31,780 --> 00:02:35,610
fait quasi instantanément et il a besoin

81
00:02:33,610 --> 00:02:38,860
de rendre producto table pour rendre

82
00:02:35,860 --> 00:02:40,110
reproductible il va devoir rendre chaque

83
00:02:38,110 --> 00:02:42,780
sous composants et c'est sous composants

84
00:02:40,780 --> 00:02:44,940
il faut mettre chacun 500 millisecondes

85
00:02:42,940 --> 00:02:45,620
et c'est pour ça que ça bloque un petit

86
00:02:44,620 --> 00:02:47,300
peu le système

87
00:02:45,300 --> 00:02:50,650
donc on peut se dire c'est un petit peu

88
00:02:47,650 --> 00:02:51,080
dommage parce que finalement entre le

89
00:02:50,080 --> 00:02:53,729
moment où j'ai tapé quelque chose ou que

90
00:02:51,729 --> 00:02:55,560
ou le moment où j'ai coché cette case là

91
00:02:53,560 --> 00:02:55,419
par exemple la ligne football ou

92
00:02:55,419 --> 00:02:57,870
baseball

93
00:02:55,870 --> 00:02:58,669
elle ne change pas nécessairement donc

94
00:02:57,669 --> 00:03:00,720
c'est un petit peu dommage de faire

95
00:02:58,720 --> 00:03:02,699
autant de renders et on peut s'assurer

96
00:03:00,699 --> 00:03:07,560
de ce nombre de renders en mettant ici

97
00:03:02,560 --> 00:03:09,479
un console point log renders on va le

98
00:03:07,479 --> 00:03:11,729
voir au premier affichage on a six fois

99
00:03:09,729 --> 00:03:13,739
renders qui est appelée si je coche

100
00:03:11,739 --> 00:03:15,989
cette case là on va avoir quatre fois

101
00:03:13,989 --> 00:03:16,340
renders qui est appelé en plus nous

102
00:03:15,340 --> 00:03:18,090
disent au total

103
00:03:16,090 --> 00:03:21,099
parce qu'on a quatre composants six

104
00:03:18,099 --> 00:03:22,190
jours d'école on va avoir seize rendu et

105
00:03:21,190 --> 00:03:23,569
comme on peut le penser mais c'est un

106
00:03:22,569 --> 00:03:25,830
petit peu dommage parce que les lignes

107
00:03:23,830 --> 00:03:28,870
elles ne changent pas en fait à 3 chaque

108
00:03:25,870 --> 00:03:30,989
chose entre chaque filtre même si on a

109
00:03:28,989 --> 00:03:33,970
changé le filtre finalement une ligne

110
00:03:30,970 --> 00:03:35,819
produit ne dépend que du produit dans ce

111
00:03:33,819 --> 00:03:37,530
cas là on peut utiliser ce que l'on

112
00:03:35,530 --> 00:03:39,810
appelle des purs compo net un composant

113
00:03:37,810 --> 00:03:42,669
pur c'est un composant qui ne sera rendu

114
00:03:39,669 --> 00:03:44,789
que si son état où ses propriétés change

115
00:03:42,789 --> 00:03:46,800
si un des deux éléments change ou même

116
00:03:44,800 --> 00:03:47,449
les deux mains dans ce cas là il appelle

117
00:03:46,449 --> 00:03:49,470
renders

118
00:03:47,470 --> 00:03:51,150
si les éléments ne change pas dans ce

119
00:03:49,150 --> 00:03:53,370
cas là il ne rappelle pas les choses

120
00:03:51,370 --> 00:03:55,500
vous pouvez utiliser des purs

121
00:03:53,500 --> 00:03:56,330
pomponnettes de deux manières

122
00:03:55,330 --> 00:04:00,830
si vous avez un composant sous forme de

123
00:03:56,830 --> 00:04:03,370
classe il suffit ici de rajouter un

124
00:04:00,370 --> 00:04:05,729
externe de réac pointures campo net et

125
00:04:03,729 --> 00:04:08,709
si votre composants et sous forme de

126
00:04:05,709 --> 00:04:10,550
fonction vous pouvez le redéfinir

127
00:04:08,550 --> 00:04:12,410
en utilisant la fonction react points

128
00:04:10,410 --> 00:04:13,150
mais mou donc je peux ici créer une

129
00:04:12,150 --> 00:04:17,889
constante qui va s'appeler producteurs

130
00:04:13,889 --> 00:04:20,699
oh ça va rentrer en collision dont

131
00:04:17,699 --> 00:04:23,850
conservent leur renommée composantes et

132
00:04:20,850 --> 00:04:26,089
je veux lui dire de faire un react

133
00:04:23,089 --> 00:04:29,519
points memo et je vais du passé un

134
00:04:26,519 --> 00:04:30,220
paramètre ma fonction producteurs aux

135
00:04:29,220 --> 00:04:32,120
compos net

136
00:04:30,120 --> 00:04:35,459
voilà ce sont les deux manières de créer

137
00:04:32,459 --> 00:04:37,430
un composant pur je vais laisser dans

138
00:04:35,430 --> 00:04:38,110
mon composants ici le console points

139
00:04:37,110 --> 00:04:42,699
block de renders pour que vous puissiez

140
00:04:38,699 --> 00:04:45,509
voir la différence si je réactualise

141
00:04:42,509 --> 00:04:46,300
j'ai bien s'y rende à l'état initial

142
00:04:45,300 --> 00:04:48,980
et lorsque je coche cette case là on

143
00:04:46,980 --> 00:04:50,120
voit qu'il n'ya pas de rendre du

144
00:04:48,120 --> 00:04:52,579
supplémentaires tout simplement il a

145
00:04:50,579 --> 00:04:54,769
détecté que ces lignes là on les avait

146
00:04:52,769 --> 00:04:56,569
déjà rendu à l'étape précédente donc ce

147
00:04:54,569 --> 00:04:58,759
n'est pas utile de rendre les choses vu

148
00:04:56,759 --> 00:05:00,110
que le paramètre qu'il reçoive

149
00:04:58,110 --> 00:05:02,930
producteur n'a pas changé si je décroche

150
00:05:00,930 --> 00:05:03,519
on va voir de rendu supplémentaires

151
00:05:02,519 --> 00:05:04,959
parce qu'il ya de nouveaux éléments qui

152
00:05:03,959 --> 00:05:06,620
ont été rajoutés

153
00:05:04,620 --> 00:05:08,329
donc là il a besoin de l'erreur entre

154
00:05:06,329 --> 00:05:10,759
mais on voit déjà que en optimisent bien

155
00:05:08,759 --> 00:05:11,500
les performances à ce niveau là parce

156
00:05:10,500 --> 00:05:13,970
qu'à chaque fois qu'on va avoir un

157
00:05:11,970 --> 00:05:16,918
élément il ne va pas être obligé de

158
00:05:13,918 --> 00:05:18,709
rappeler le render alors on peut se dire

159
00:05:16,709 --> 00:05:21,779
finalement est-ce que je ne devrais pas

160
00:05:18,779 --> 00:05:22,418
rendre tous mes composants sous forme de

161
00:05:21,418 --> 00:05:23,259
pure convenance

162
00:05:22,259 --> 00:05:25,610
ça me permettrait d'optimiser les

163
00:05:23,610 --> 00:05:28,860
performances de manière générale alors

164
00:05:25,860 --> 00:05:30,139
pas forcément premièrement il faut

165
00:05:28,139 --> 00:05:31,690
savoir que lorsque vous utilisez un pur

166
00:05:30,690 --> 00:05:33,350
complot nantes

167
00:05:31,350 --> 00:05:34,089
vous allez demander à réate sous

168
00:05:33,089 --> 00:05:36,440
certaines conditions de ne pas rendre

169
00:05:34,440 --> 00:05:38,569
les choses et parfois vous pourriez

170
00:05:36,569 --> 00:05:40,370
avoir des bugs avec des rendus que vous

171
00:05:38,370 --> 00:05:41,199
attendriez qui ne se font pas et on va

172
00:05:40,199 --> 00:05:44,610
avoir quelques exemples de problème

173
00:05:41,610 --> 00:05:45,009
juste après l'autre chose c'est que

174
00:05:44,009 --> 00:05:46,000
maintenant à chaque fois qu'il doit

175
00:05:45,000 --> 00:05:46,350
rendre ce composant il doit faire une

176
00:05:46,350 --> 00:05:48,949
comparaison

177
00:05:46,949 --> 00:05:50,389
si vous avez beaucoup de propriétés

178
00:05:48,389 --> 00:05:51,130
beaucoup d'états cette comparaison peut

179
00:05:50,130 --> 00:05:54,899
avoir un coût donc si on prend l'exemple

180
00:05:51,899 --> 00:05:55,540
d'un petit bouton par exemple c'est pas

181
00:05:54,540 --> 00:05:57,860
forcément utile d'aller faire des

182
00:05:55,860 --> 00:05:58,750
comparaisons en permanence on rend le

183
00:05:57,750 --> 00:06:00,860
bouton et ce n'est pas grave

184
00:05:58,860 --> 00:06:02,509
donc on réservera l'utilisation de

185
00:06:00,509 --> 00:06:04,190
composants pur vraiment pour des

186
00:06:02,190 --> 00:06:06,259
éléments qui sont importants qui ont

187
00:06:04,259 --> 00:06:08,360
peut-être une logique complexe et pour

188
00:06:06,360 --> 00:06:11,930
lequel on sait les conditions de rendu

189
00:06:08,930 --> 00:06:13,430
ça nous amène justement à seconde

190
00:06:11,430 --> 00:06:15,380
problématique qui est la notion dit

191
00:06:13,380 --> 00:06:17,300
mutabilité donc lorsque l'on va

192
00:06:15,300 --> 00:06:18,038
travailler avec des composants pur il

193
00:06:17,038 --> 00:06:20,329
faudra bien faire attention à ce que les

194
00:06:18,329 --> 00:06:21,149
propriétés change

195
00:06:20,149 --> 00:06:23,079
alors je vais vous faire un exemple

196
00:06:21,079 --> 00:06:27,750
concret ça vous parlera plus donc on va

197
00:06:23,750 --> 00:06:29,230
imaginer que notre filter producta bhl

198
00:06:27,230 --> 00:06:32,290
on le transforme en pur complot net

199
00:06:29,290 --> 00:06:33,569
ici on lui dit tu es un pur complot net

200
00:06:32,569 --> 00:06:36,860
vu qu'ils fonctionnaient sous forme de

201
00:06:33,860 --> 00:06:40,769
classe le rendre pur et très simple donc

202
00:06:36,769 --> 00:06:43,639
ce filtered filtrables producta bhl il

203
00:06:40,639 --> 00:06:45,040
ne sera rendu que si son état change ou

204
00:06:43,040 --> 00:06:47,380
si la liste des produits changent donc

205
00:06:45,380 --> 00:06:49,449
on va s'imaginer du coup au niveau de

206
00:06:47,449 --> 00:06:51,880
notre réacteur ander attendre une

207
00:06:49,880 --> 00:06:55,680
seconde et refaire un rendu avec une

208
00:06:51,680 --> 00:06:58,639
liste de produits différentes alors jour

209
00:06:55,639 --> 00:07:02,930
monte on va reprendre cette constante là

210
00:06:58,930 --> 00:07:03,029
on va la mettre juste en dessous et on

211
00:07:02,029 --> 00:07:06,649
va rajouter un nouveau produit

212
00:07:03,649 --> 00:07:08,230
on croise imaginaire ajouter ici le

213
00:07:06,230 --> 00:07:10,709
nexus 8 est il au même prix que le nexus

214
00:07:08,709 --> 00:07:13,550
7,7 constante je vais l'appeler

215
00:07:10,550 --> 00:07:16,670
production 2 maintenant je vais demander

216
00:07:13,670 --> 00:07:18,009
à mon script d'attendre une seconde et

217
00:07:16,009 --> 00:07:21,350
au bout d'une seconde je vais revendeurs

218
00:07:18,350 --> 00:07:23,139
tout cet élément là on va attendre un

219
00:07:21,139 --> 00:07:24,300
petit peu plus donc on va faire un cette

220
00:07:23,300 --> 00:07:26,050
taille nantes

221
00:07:24,050 --> 00:07:28,720
donc on en sera une fonction qui va

222
00:07:26,720 --> 00:07:31,639
relancer à nouveau rendus mais cette

223
00:07:28,639 --> 00:07:34,370
fois ci avec la seconde liste de

224
00:07:31,370 --> 00:07:37,490
produits et on va attendre 200 fait 2000

225
00:07:34,490 --> 00:07:38,160
mini secondes donc on voit qu'au bout de

226
00:07:37,160 --> 00:07:42,120
deux mille millisecondes

227
00:07:38,120 --> 00:07:44,019
le nexus 8 arrive je vais au niveau de

228
00:07:42,019 --> 00:07:50,060
mon vendeur ici mettre un console point

229
00:07:44,060 --> 00:07:52,389
log de grandeur si je réactualise on

230
00:07:50,389 --> 00:07:54,430
voit qu'au bout de deux secondes on a

231
00:07:52,430 --> 00:07:55,139
bien un second renders qui est appelé

232
00:07:54,139 --> 00:07:57,639
parce que la liste des produits changent

233
00:07:55,639 --> 00:07:59,470
et du coup le composant change

234
00:07:57,470 --> 00:08:01,569
une place est en concordance avec ce

235
00:07:59,569 --> 00:08:03,699
qu'on attend maintenant imaginons on

236
00:08:01,699 --> 00:08:06,800
n'est pas forcément si mal que ça et on

237
00:08:03,800 --> 00:08:09,709
se dit je vais simplement poussé dans

238
00:08:06,709 --> 00:08:11,079
mon tableau produits le nouvel élément

239
00:08:09,079 --> 00:08:14,600
donc on va tout simplement lui dire que

240
00:08:11,600 --> 00:08:18,779
au niveau de production de sa sera égale

241
00:08:14,779 --> 00:08:22,560
la production suite je fais un

242
00:08:18,560 --> 00:08:25,970
producteur deux fois un push et je push

243
00:08:22,970 --> 00:08:29,329
mon nouvel élément

244
00:08:25,329 --> 00:08:30,389
je sauvegarde j'attende de seconde et au

245
00:08:29,389 --> 00:08:32,980
bout de deux secondes je remarque qu'ils

246
00:08:30,980 --> 00:08:33,960
ne se passe rien pourtant on pourrait se

247
00:08:32,960 --> 00:08:35,679
dire oui mais

248
00:08:33,679 --> 00:08:36,149
changer le listing produit et je

249
00:08:35,149 --> 00:08:39,710
rappelle renders donc normalement il

250
00:08:36,710 --> 00:08:40,320
devrait rendre les choses et c'est

251
00:08:39,320 --> 00:08:43,759
justement là qu'il ya un problème

252
00:08:40,759 --> 00:08:45,219
en effet la vous ce que vous faites ici

253
00:08:43,219 --> 00:08:47,200
c'est une mutation c'est à dire que vous

254
00:08:45,200 --> 00:08:49,419
muté l'objet producteurs et vous

255
00:08:47,419 --> 00:08:51,700
rajoutez une nouvelle valeur donc lui

256
00:08:49,700 --> 00:08:53,230
lorsque vous avez défini que ce

257
00:08:51,230 --> 00:08:54,330
composant était une composante pur il

258
00:08:53,330 --> 00:08:56,980
fait juste une vérification de surface

259
00:08:54,980 --> 00:08:58,630
c'est à dire qu'il ne va pas vérifié que

260
00:08:56,630 --> 00:08:59,339
à l'intérieur de votre objet production

261
00:08:58,339 --> 00:09:01,509
vous n'ayez pas les mêmes produits que

262
00:08:59,509 --> 00:09:04,549
l'objet précédent oui ils comparent

263
00:09:01,549 --> 00:09:05,159
juste le nouvel objet à l'ancien vu que

264
00:09:04,159 --> 00:09:07,600
vous avez fait une mutation

265
00:09:05,600 --> 00:09:08,190
lorsqu'il fait une comparaison il dit

266
00:09:07,190 --> 00:09:10,330
non mais c'est toujours même objet

267
00:09:08,330 --> 00:09:11,009
certes tu l'a changée mais moi je vous

268
00:09:10,009 --> 00:09:13,809
recommande le savoir je compare l'ancien

269
00:09:11,809 --> 00:09:15,700
objets ou nouveau et c'est le même objet

270
00:09:13,700 --> 00:09:17,759
la même référence et ça pose un problème

271
00:09:15,759 --> 00:09:20,990
donc pour remédier à ce problème là

272
00:09:17,990 --> 00:09:20,059
lorsqu'on fait un set state et lorsque

273
00:09:20,059 --> 00:09:22,899
l'on change l'état

274
00:09:20,899 --> 00:09:25,700
il faudra éviter d' altérer l'état

275
00:09:22,700 --> 00:09:26,250
précédent donc la bonne solution pour

276
00:09:25,250 --> 00:09:28,899
faire ce que l'on veut faire ici serait

277
00:09:26,899 --> 00:09:31,429
tout simplement de dire bon des produits

278
00:09:28,429 --> 00:09:34,039
pseu 2 ça va être la liste de nos

279
00:09:31,039 --> 00:09:36,549
produits donc production auxquelles je

280
00:09:34,549 --> 00:09:41,380
rajoute une nouvelle entrée comme

281
00:09:36,380 --> 00:09:41,028
ceux-ci up et dans ce cas là lorsque je

282
00:09:41,028 --> 00:09:42,600
sauvegarde

283
00:09:41,600 --> 00:09:44,860
on va voir qu'au bout de deux secondes

284
00:09:42,860 --> 00:09:46,750
va effectivement avoir un second rang du

285
00:09:44,750 --> 00:09:48,089
nôtres nexus 8

286
00:09:46,089 --> 00:09:50,500
donc lorsque vous souhaitez modifier un

287
00:09:48,500 --> 00:09:54,240
tableau mais faudra utiliser ce spread

288
00:09:50,240 --> 00:09:59,669
opérateurs pour ajouter une plaie avant

289
00:09:54,669 --> 00:10:01,149
ou après donc en faisant sens si vous

290
00:09:59,149 --> 00:10:02,009
voulez rajouter une clé à la fin si vous

291
00:10:01,009 --> 00:10:04,299
voulez rajouter une clé au début mais

292
00:10:02,299 --> 00:10:05,159
vous ferez une 8ème et ensuite vous

293
00:10:04,159 --> 00:10:06,000
rajoutez les items

294
00:10:05,000 --> 00:10:08,769
si vous voulez rajouter une clé au

295
00:10:06,769 --> 00:10:10,799
milieu c'est un petit peu plus compliqué

296
00:10:08,799 --> 00:10:12,820
ensuite si vous voulez modifier des

297
00:10:10,820 --> 00:10:12,110
objets mais il faudra faire un peu la

298
00:10:12,110 --> 00:10:14,559
même chose

299
00:10:12,559 --> 00:10:17,539
on s'imagine que vous passez un objet et

300
00:10:14,539 --> 00:10:20,450
ensuite vous rajoutez la clé que vous

301
00:10:17,450 --> 00:10:22,809
avez besoin de rajouter comme ceci donc

302
00:10:20,809 --> 00:10:24,039
à chaque fois que vous faites une

303
00:10:22,039 --> 00:10:25,500
mutation 1,7 state il ne faut pas lutter

304
00:10:24,500 --> 00:10:27,759
l'état précédent mais il faut tout

305
00:10:25,759 --> 00:10:29,470
simplement envoyé un nouvel objet

306
00:10:27,470 --> 00:10:31,809
représentant votre nouvel état donc

307
00:10:29,809 --> 00:10:33,220
c'est très important surtout si vous

308
00:10:31,220 --> 00:10:35,019
travaillez avec des composants pur parce

309
00:10:33,019 --> 00:10:38,590
que sinon vous allez avoir ce problème

310
00:10:35,590 --> 00:10:40,149
l'or aussi ça va nous amener à un second

311
00:10:38,149 --> 00:10:42,070
problème on va retirer cette petite

312
00:10:40,070 --> 00:10:43,350
logique là et on va défaire notre pure

313
00:10:42,350 --> 00:10:48,179
qu'on connecte

314
00:10:43,179 --> 00:10:50,470
ici on va revendre notre propre

315
00:10:48,470 --> 00:10:53,750
producteur au comme un composant pur

316
00:10:50,750 --> 00:10:55,120
donc à ce niveau là j'ai juste à lui

317
00:10:53,120 --> 00:10:57,250
dire voilà je veux faire une constante

318
00:10:55,250 --> 00:11:01,559
producteurs on égalerait acte point mes

319
00:10:57,559 --> 00:11:02,519
mots et je fais ça donc encore une fois

320
00:11:01,519 --> 00:11:05,690
elles ce sont deux manières différentes

321
00:11:02,690 --> 00:11:08,779
de définir des composants qui sont des

322
00:11:05,779 --> 00:11:10,149
composants pur react points memo dans le

323
00:11:08,149 --> 00:11:11,100
cas d'une fonction eric pointures

324
00:11:10,100 --> 00:11:13,509
component dans le cas d'une classe

325
00:11:11,509 --> 00:11:15,370
d'ailleurs pour ceux qui sont intéressés

326
00:11:13,370 --> 00:11:17,500
par la terminologie ici mes mots c'est

327
00:11:15,500 --> 00:11:19,120
le diminutif de mémorisation

328
00:11:17,120 --> 00:11:20,190
c'est tout simplement une technique qui

329
00:11:19,190 --> 00:11:22,659
consiste à mémoriser les valeurs

330
00:11:20,659 --> 00:11:24,759
retourné par une fonction pour éviter de

331
00:11:22,759 --> 00:11:26,529
l'art est appelé voilà pourquoi on

332
00:11:24,529 --> 00:11:29,960
appelle sa mémorisation et purpan

333
00:11:26,960 --> 00:11:30,240
potenza viennent des fonctions pur c'est

334
00:11:29,240 --> 00:11:33,830
à dire que c'est une fonction qui change

335
00:11:30,830 --> 00:11:35,320
de retour seulement si ces valeurs à

336
00:11:33,320 --> 00:11:36,929
d'entrée ont changé et si non qui rend

337
00:11:35,929 --> 00:11:38,740
toujours la même chose

338
00:11:36,740 --> 00:11:39,269
donc c'est pour ça qu'on a ces deux

339
00:11:38,269 --> 00:11:41,889
termes qui sont utilisés donc je

340
00:11:39,889 --> 00:11:44,779
réactualise ma page et je vais mettre

341
00:11:41,779 --> 00:11:51,179
ici un console points loeb a encore une

342
00:11:44,179 --> 00:11:53,470
fois de renders productif aussi donc là

343
00:11:51,470 --> 00:11:55,269
on a bien une optimisation qui est fait

344
00:11:53,269 --> 00:11:56,130
si je coche cette case là je n'ai pas de

345
00:11:55,130 --> 00:12:00,539
rancoeur produits nouveaux qui est

346
00:11:56,539 --> 00:12:02,230
appelé maintenant imaginons que lorsque

347
00:12:00,230 --> 00:12:03,000
je fais un vendeur produits que je me

348
00:12:02,000 --> 00:12:05,559
dis je vais te passer un petit colbac

349
00:12:03,559 --> 00:12:07,059
donc lorsque je fais un producteur ou

350
00:12:05,059 --> 00:12:09,039
ici je vais dit on clique

351
00:12:07,039 --> 00:12:11,169
même si derrière ce n'est pas interprété

352
00:12:09,169 --> 00:12:14,990
et là je lui passe une fonction et on

353
00:12:11,990 --> 00:12:17,330
s'imagine que j'ai une fonction qui

354
00:12:14,330 --> 00:12:20,179
s'appelle onclick et je ferai un vice

355
00:12:17,179 --> 00:12:22,240
point and click et je pourrais faire un

356
00:12:20,240 --> 00:12:24,130
bail ne vise par exemple où je pourrais

357
00:12:22,130 --> 00:12:27,409
lui passer une fonction en écrivant de

358
00:12:24,409 --> 00:12:31,350
cette manière là et là je sais pas ce

359
00:12:27,350 --> 00:12:32,519
qu'on pourrait mettre juste comme ça si

360
00:12:31,519 --> 00:12:34,330
je sauvegarde

361
00:12:32,330 --> 00:12:36,370
on va voir quelque chose d'étrange si je

362
00:12:34,370 --> 00:12:37,139
décoche cette case là et si je re

363
00:12:36,139 --> 00:12:39,940
décoche cette case là on voit que

364
00:12:37,940 --> 00:12:41,080
contrairement à tout à l'heure en a

365
00:12:39,080 --> 00:12:43,269
plein de rendu qui sont ré appelé

366
00:12:41,269 --> 00:12:44,309
pourquoi tout simplement parce qu en

367
00:12:43,309 --> 00:12:46,720
définissant les call back de cette

368
00:12:44,720 --> 00:12:48,549
manière là à chaque fois que vous vous

369
00:12:46,549 --> 00:12:50,590
rappelez cette fonction là cette

370
00:12:48,590 --> 00:12:52,750
fonction est différente elle n'est pas

371
00:12:50,750 --> 00:12:55,639
mémorisé quelque part et du coup à

372
00:12:52,639 --> 00:12:58,460
chaque fois que vous avez 7 rendu qui

373
00:12:55,460 --> 00:13:00,159
est demandé malgré la mémorisation il

374
00:12:58,159 --> 00:13:02,350
dit oui mais le colback est différent du

375
00:13:00,350 --> 00:13:04,090
call back précédent du coup vu que le

376
00:13:02,090 --> 00:13:06,070
call back n'est pas le même objet ben je

377
00:13:04,070 --> 00:13:07,320
dois redéclencher invendus et le fait

378
00:13:06,320 --> 00:13:09,850
d'envoyer de décrire les call back

379
00:13:07,850 --> 00:13:11,649
directement comme ça même si ça peut

380
00:13:09,649 --> 00:13:13,779
paraître pratique au premier abord à un

381
00:13:11,779 --> 00:13:14,159
effet contre-productif

382
00:13:13,159 --> 00:13:16,299
ça veut dire qu'à chaque fois qu'il ya

383
00:13:14,299 --> 00:13:17,519
un rendu le colback est différent et si

384
00:13:16,519 --> 00:13:19,929
vous avez derrière des composants qui

385
00:13:17,929 --> 00:13:21,490
sont pures ou des composants qui sont

386
00:13:19,490 --> 00:13:23,559
mémorisées ils ne prendront pas en

387
00:13:21,559 --> 00:13:24,059
compte la mémorisation parce que le

388
00:13:23,059 --> 00:13:26,620
colback change à chaque fois qu'ils

389
00:13:24,620 --> 00:13:28,029
nient à nouveau rendus par le composant

390
00:13:26,029 --> 00:13:30,340
par an donc c'est pour ça que c'est très

391
00:13:28,340 --> 00:13:32,289
important lorsqu'on utilise des call

392
00:13:30,289 --> 00:13:34,450
back comme on le fait depuis le début de

393
00:13:32,450 --> 00:13:36,130
cette formation d'utiliser cette

394
00:13:34,130 --> 00:13:39,710
approche-là du bind vis des le

395
00:13:36,710 --> 00:13:40,049
constructeur comme ça ce que le bac est

396
00:13:39,049 --> 00:13:42,580
défini une bonne fois pour toute dans

397
00:13:40,580 --> 00:13:44,740
cette classe là et il ne changera jamais

398
00:13:42,740 --> 00:13:47,750
si vous utilisiez un bail de vis

399
00:13:44,750 --> 00:13:48,360
directement à ce niveau là à chaque fois

400
00:13:47,360 --> 00:13:50,860
que vous appelez un bail de vie il

401
00:13:48,860 --> 00:13:52,330
redéfinit une nouvelle version de la

402
00:13:50,330 --> 00:13:53,039
fonction à chaque fois vous vous

403
00:13:52,039 --> 00:13:55,720
retrouveriez avec une nouvelle fonction

404
00:13:53,720 --> 00:13:57,220
et les composants pure qui sont en

405
00:13:55,220 --> 00:13:59,200
dessous déclencherait des rendus parce

406
00:13:57,200 --> 00:14:00,149
qu'il pense parce qu'ils penseront que

407
00:13:59,149 --> 00:14:03,799
ce qu'ils reçoivent en paramètre a

408
00:14:00,799 --> 00:14:06,350
changé donc ça c'est très très important

409
00:14:03,350 --> 00:14:07,470
de bien bien assimilés sont aussi faut

410
00:14:06,470 --> 00:14:09,970
retenir de cette vidéo c'est que

411
00:14:07,970 --> 00:14:12,860
basiquement si vous avez des composants

412
00:14:09,860 --> 00:14:14,409
qui sont particuliers qui ne doivent pas

413
00:14:12,409 --> 00:14:16,690
être revendu systématiquement même si

414
00:14:14,690 --> 00:14:18,610
leurs parents et re rendu et qui ne

415
00:14:16,610 --> 00:14:20,590
doivent être rendus que si une des

416
00:14:18,590 --> 00:14:22,929
propriétés ou leur état change dans ce

417
00:14:20,929 --> 00:14:24,100
cas là ça peut être intéressant

418
00:14:22,100 --> 00:14:25,440
d'utiliser des purs qu'on connaît donc

419
00:14:24,440 --> 00:14:28,639
si on prend le cas de facebook par

420
00:14:25,639 --> 00:14:30,309
exemple on a au milieu un news feed qui

421
00:14:28,309 --> 00:14:32,470
liste l'ensemble des news on peut

422
00:14:30,470 --> 00:14:33,120
imaginer que quand je tape une recherche

423
00:14:32,120 --> 00:14:35,830
en eau passe mais on n'a pas envie de

424
00:14:33,830 --> 00:14:37,750
rendre systématiquement ce newsfeed

425
00:14:35,750 --> 00:14:40,909
qu'on peut lui dire mais lui ne dépend

426
00:14:37,909 --> 00:14:41,070
que du paramètre entrée qui serait la

427
00:14:40,070 --> 00:14:43,630
liste de news il ya que quand la liste

428
00:14:41,630 --> 00:14:46,880
de news change qui doit être rendu donc

429
00:14:43,880 --> 00:14:47,039
ça peut être pertinent de créer un pur

430
00:14:46,039 --> 00:14:49,419
comprenant ce niveau là

431
00:14:47,419 --> 00:14:52,940
par contre si vous avez juste besoin

432
00:14:49,940 --> 00:14:54,190
d'avoir un bouton ça ne sert à rien de

433
00:14:52,190 --> 00:14:56,500
le mémoriser ça va demander un sort à un

434
00:14:54,500 --> 00:14:58,750
coût supplémentaire pour économiser un

435
00:14:56,750 --> 00:15:00,309
rendu qui est vraiment minime donc ça ne

436
00:14:58,309 --> 00:15:01,139
vaut pas le coup par contre voilà gardé

437
00:15:00,139 --> 00:15:03,909
cette idée en tête que si vous avez des

438
00:15:01,909 --> 00:15:05,500
composants ou savait que la logique de

439
00:15:03,500 --> 00:15:06,090
rendu peut être un petit peu complexe

440
00:15:05,090 --> 00:15:07,500
dans ce cas là on utilisera les purs

441
00:15:06,500 --> 00:15:10,450
compo net

442
00:15:07,450 --> 00:15:12,250
ensuite lorsque l'on fait 17 state on

443
00:15:10,250 --> 00:15:14,500
fera attention à ne jamais muter les

444
00:15:12,500 --> 00:15:16,299
valeurs c'est à dire que si on change

445
00:15:14,299 --> 00:15:16,220
une valeur on va créer une nouvelle

446
00:15:16,220 --> 00:15:18,820
version

447
00:15:16,820 --> 00:15:20,769
donc si on travaille que les objets dont

448
00:15:18,769 --> 00:15:22,210
on va créer un nouvel objet soit en

449
00:15:20,210 --> 00:15:23,070
utilisant le spread opérateurs sont en

450
00:15:22,070 --> 00:15:25,539
utilisant la fonction abject quand un

451
00:15:23,539 --> 00:15:26,460
signe et si on travaille avec les

452
00:15:25,460 --> 00:15:27,990
tableaux on évitera à tout prix

453
00:15:26,990 --> 00:15:30,860
d'utiliser un push

454
00:15:27,860 --> 00:15:32,529
on créera un nouveau tableau et on

455
00:15:30,529 --> 00:15:34,149
rajoutera une valeur soit en utilisant

456
00:15:32,149 --> 00:15:35,100
le spread operator soit en utilisant ce

457
00:15:34,100 --> 00:15:37,899
live donc là à vous de voir mais

458
00:15:35,899 --> 00:15:39,309
l'intérêt vraiment c'est de créer une

459
00:15:37,309 --> 00:15:41,919
nouvelle version du tableau les éléments

460
00:15:39,919 --> 00:15:42,120
à l'intérieur du tableau peuvent ne pas

461
00:15:41,120 --> 00:15:44,889
changer ça paraît logique mais par

462
00:15:42,889 --> 00:15:45,179
contre le tableau doit d'être une

463
00:15:44,179 --> 00:15:47,500
nouvelle version sinon lorsqu'il va

464
00:15:45,500 --> 00:15:48,240
faire des comparaisons il va détecter

465
00:15:47,240 --> 00:15:50,860
qu'il n'y a pas de rendu à faire et ça

466
00:15:48,860 --> 00:15:52,019
peut poser des problèmes

467
00:15:50,019 --> 00:15:54,159
enfin dernier point lorsque l'on

468
00:15:52,159 --> 00:15:56,049
utilisera des call back et pour faire

469
00:15:54,049 --> 00:15:57,059
remonter de l'information par exemple on

470
00:15:56,059 --> 00:15:59,889
fera attention à envoyer toujours la

471
00:15:57,889 --> 00:16:01,899
même version de la fonction et ne pas

472
00:15:59,899 --> 00:16:04,519
définir les fonctions à la volée parce

473
00:16:01,519 --> 00:16:05,070
que sinon ça veut dire que l'enfant aura

474
00:16:04,070 --> 00:16:07,450
toujours l'impression de recevoir une

475
00:16:05,450 --> 00:16:09,460
nouvelle version du call back et même si

476
00:16:07,460 --> 00:16:11,289
votre composants et pur sarr déclenché

477
00:16:09,289 --> 00:16:13,690
le raid est rendu enfin une dernière

478
00:16:11,690 --> 00:16:16,639
chose je les ai volontairement essayé de

479
00:16:13,639 --> 00:16:17,429
l'éclipsé dans ce chapitre là mais vous

480
00:16:16,429 --> 00:16:19,750
avez une fonction qu'il est possible

481
00:16:17,750 --> 00:16:21,549
d'utiliser au niveau de vos composants

482
00:16:19,549 --> 00:16:23,980
qui est la fonction schuhl component à

483
00:16:21,980 --> 00:16:25,750
beit donc c'est quelque chose qui va

484
00:16:23,750 --> 00:16:27,850
être appelé et qui permet de savoir si

485
00:16:25,850 --> 00:16:29,710
le composant devrait être mis à jour

486
00:16:27,710 --> 00:16:32,690
donc cette fonction s'appelle schuld

487
00:16:29,690 --> 00:16:34,630
component gates elle va prendre deux

488
00:16:32,630 --> 00:16:36,700
paramètres le premier c'est les next

489
00:16:34,700 --> 00:16:38,289
props c'est à dire les nouvelles propres

490
00:16:36,289 --> 00:16:41,090
ce qui va recevoir et le second sénèque

491
00:16:38,090 --> 00:16:43,179
state cette fonction elle doit renvoyer

492
00:16:41,179 --> 00:16:44,159
trou ou fold pour dire est ce qu'elle

493
00:16:43,159 --> 00:16:45,570
doit faire avec dead c'est à dire est ce

494
00:16:44,570 --> 00:16:48,830
que la fonction renders doit être

495
00:16:45,830 --> 00:16:50,139
rappelé là on va s'imaginer qu'on aurait

496
00:16:48,139 --> 00:16:52,659
un return false tout le temps est au

497
00:16:50,659 --> 00:16:55,490
niveau de cette fonction renders je vais

498
00:16:52,490 --> 00:16:57,029
faire une console point d'orgue renders

499
00:16:55,029 --> 00:16:58,289
si maintenant je clique sur une tchèque

500
00:16:57,289 --> 00:16:59,549
box ou que j'ai c'est de taper une

501
00:16:58,549 --> 00:17:00,379
recherche on voit

502
00:16:59,379 --> 00:17:03,578
qui ne se passe absolument plus rien

503
00:17:00,578 --> 00:17:04,129
parce que lorsque react je vois qu'il ya

504
00:17:03,129 --> 00:17:06,179
un changement d'état il va utiliser

505
00:17:04,179 --> 00:17:08,159
cette fonction là pour savoir s'il y en

506
00:17:06,159 --> 00:17:12,318
a 1 heure et 7 fonctionnaires envoyés et

507
00:17:08,318 --> 00:17:14,099
du coup on n'a aucun nouveau rendu donc

508
00:17:12,099 --> 00:17:15,500
on va juste débugger next props et next

509
00:17:14,500 --> 00:17:17,148
estate

510
00:17:15,148 --> 00:17:19,798
lorsque vous faites un extend de ryad

511
00:17:17,798 --> 00:17:21,419
point pure convenance

512
00:17:19,419 --> 00:17:23,279
c'est en fait une classe qui fonctionne

513
00:17:21,279 --> 00:17:25,349
comme un composant classique sauf que

514
00:17:23,349 --> 00:17:27,240
vous avez déjà un shoot component dead

515
00:17:25,240 --> 00:17:29,519
qui a été créé et qui compare simplement

516
00:17:27,519 --> 00:17:32,980
que les knicks propres et les next state

517
00:17:29,980 --> 00:17:33,589
ne ne doivent pas être identique donc

518
00:17:32,589 --> 00:17:35,940
c'est vraiment assez rare qu'on ait

519
00:17:33,940 --> 00:17:37,558
besoin de définir nous mêmes cette

520
00:17:35,558 --> 00:17:38,058
fonction là ça peut être utile dans

521
00:17:37,058 --> 00:17:38,200
certains cas donc c'est pour ça que je

522
00:17:38,200 --> 00:17:40,589
vous montre

523
00:17:38,589 --> 00:17:41,298
mais de manière générale on va plutôt

524
00:17:40,298 --> 00:17:43,950
utiliser les purs component et on ne va

525
00:17:41,950 --> 00:17:45,329
pas forcément définir cette logique là

526
00:17:43,329 --> 00:17:46,159
le problème quand vous commencez à

527
00:17:45,159 --> 00:17:49,839
changer cette structure là et cette

528
00:17:46,839 --> 00:17:51,690
logique là c'est que vous pouvez avoir

529
00:17:49,690 --> 00:17:53,669
des vous pouvez derrière avoir des

530
00:17:51,669 --> 00:17:55,409
problèmes avec des rendus qui devrait se

531
00:17:53,409 --> 00:17:57,179
faire qui ne se font plus et ça pose au

532
00:17:55,179 --> 00:17:59,819
toujours un petit lot de problèmes donc

533
00:17:57,819 --> 00:18:01,200
là si j'essaie de cliquer ici

534
00:17:59,200 --> 00:18:02,058
on voit que je reçois en premier

535
00:18:01,058 --> 00:18:05,919
paramètre les nouvelles propriétés donc

536
00:18:02,919 --> 00:18:08,950
elle ne change pas et par contre je vois

537
00:18:05,950 --> 00:18:10,109
que la partie in stock en y achetant

538
00:18:08,109 --> 00:18:11,058
j'ai donc ici si on voulait faire

539
00:18:10,058 --> 00:18:16,829
quelque chose on pourrait vérifier que

540
00:18:11,829 --> 00:18:19,148
on retournerait que next props point une

541
00:18:16,148 --> 00:18:22,000
production doit être différent de vie ce

542
00:18:19,000 --> 00:18:27,648
point propre production

543
00:18:22,648 --> 00:18:30,490
il faudrait que next state filter texte

544
00:18:27,490 --> 00:18:33,038
doit être différent de vie ce point

545
00:18:30,038 --> 00:18:37,069
state point filter texte ou encore une

546
00:18:33,069 --> 00:18:39,750
fois que next state point in stock only

547
00:18:37,750 --> 00:18:40,220
doit être différent et vous avez compris

548
00:18:39,220 --> 00:18:42,960
précis donc ça c'est quelque chose qui

549
00:18:40,960 --> 00:18:44,700
est fait de manière automatique lorsque

550
00:18:42,700 --> 00:18:46,980
vous utilisez des purs complète mais

551
00:18:44,980 --> 00:18:48,929
c'est ce qui se cache sous le capot

552
00:18:46,929 --> 00:18:49,519
si maintenant j'essaie de cocher cette

553
00:18:48,519 --> 00:18:51,929
case là où de faire des recherches

554
00:18:49,929 --> 00:18:52,878
ça fonctionne convenablement et le rendu

555
00:18:51,878 --> 00:18:56,920
est appelé

556
00:18:52,920 --> 00:18:58,049
voilà pour ce principe là retenez bien

557
00:18:56,049 --> 00:19:00,390
le concept dit mutabilité et

558
00:18:58,390 --> 00:19:01,160
l'utilisation des call back en euros

559
00:19:00,160 --> 00:19:03,599
définissant pas les choses à chaque fois

560
00:19:01,599 --> 00:19:05,579
c'est vraiment les deux éléments clés

561
00:19:03,579 --> 00:19:07,319
qu'il faut comprendre dans ce chapitre

562
00:19:05,319 --> 00:19:09,930
là donc j'espère que ça vous aura permis

563
00:19:07,930 --> 00:19:10,400
d'y voir un peu plus clair et je vous

564
00:19:09,400 --> 00:19:14,630
donne donc rendez-vous dans le prochain

565
00:19:10,630 --> 00:19:14,000
chapitre nous avons parlé des références
Subtitles End: mo.dbxdb.com

